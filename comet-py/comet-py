#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Asterix data processing tool

import argparse
import fileinput
import random
import errno
import sys
from typing import *

import asterix as ast

def output(*args):
    """Like 'print', but handle broken pipe exception."""
    try:
        print(*args)
    except IOError as e:
        if e.errno == errno.EPIPE:
            sys.exit(0)

class DataFormat:
    pass

class FormatHex(DataFormat):
    """Single hex excoded datagram per line, newline separator."""

    @classmethod
    def dump(cls, s : bytes) -> None:
        output(s.hex())

    @classmethod
    def fetch(cls, s : str):
        return (bytes.fromhex(s), None)

format_input = [FormatHex]
format_output = [FormatHex]

class PCG32:
    """Simple random number generator,
    based on https://www.pcg-random.org/download.html"""

    top64 : int = pow(2, 64)
    top32 : int = pow(2, 32)

    def mod64(self, val : int) -> int: return val % self.__class__.top64
    def mod32(self, val : int) -> int: return val % self.__class__.top32

    def __init__(self, state : int = 0, inc : int = 0) -> None:
        self.state = self.mod64(state)
        self.inc = self.mod64(inc)

    def next(self) -> int:
        """Generate next 32-bit random value."""
        oldstate = self.state
        self.state = self.mod64(oldstate * 6364136223846793005 + (self.inc | 1))
        xorshifted = self.mod32(((oldstate >> 18) ^ oldstate) >> 27)
        rot = oldstate >> 59
        return self.mod32((xorshifted >> rot) | (xorshifted << ((-rot) & 31)))

    def choose(self, lst : List[Any]) -> Any:
        """Choose list element."""
        ix = self.next() % len(lst)
        return lst[ix]

    def bool(self):
        """Generate random bool value."""
        return bool(self.next() % 2)

    def bigint(self, bitsize):
        """Generate random number of arbitrary bitsize."""
        val = self.next()
        size = 32
        while True:
            if size >= bitsize:
                return val % pow(2,bitsize)
            size += 32
            val = val*pow(2,32) + self.next()

def to_edition(ed):
    """Convert edition string to a tuple, for example "1.2" -> (1,2)"""
    a,b = ed.split('.')
    return (int(a), int(b))

def show_manifest(args):

    def fmt(what, n, ed): # type: ignore
        return '{} {}, edition {}'.format(what, str(n).zfill(3), ed)

    def loop(arg, what):
        for n in sorted(ast.manifest[arg]):
            d = ast.manifest[arg][n]
            for ed in sorted(d.keys(), key=to_edition, reverse=True):
                output(fmt(what, n, ed))
                if args.latest: break
    loop('CATS', 'cat')
    loop('REFS', 'ref')

def get_selection(empty, explicit_cats, explicit_refs):
    """Get category selection."""

    def get_latest(lst):
        return sorted(lst, key=lambda pair: to_edition(pair[0]), reverse=True)[0]

    # get latest
    cats = {cat: get_latest(ast.manifest['CATS'][cat].items())[1] for cat in ast.manifest['CATS'].keys()}
    refs = {cat: get_latest(ast.manifest['REFS'][cat].items())[1] for cat in ast.manifest['REFS'].keys()}

    # cleanup if required
    if empty:
        cats = {}
        refs = {}

    # update with explicit editions
    for (a,b,c) in [
        (cats, 'CATS', explicit_cats),
        (refs, 'REFS', explicit_refs),
        ]:
        for (cat,ed) in c:
            cat = int(cat)
            a.update({cat: ast.manifest[b][cat][ed]})
    return {'CATS': cats, 'REFS': refs}

def get_expansions(selection, expansions):
    result = []
    for (cat, name) in expansions:
        cat = int(cat)
        assert cat in selection['REFS'].keys(), 'REF not defined'
        spec = selection['CATS'][cat]
        subitem = spec.variation.spec(name)
        assert issubclass(subitem, ast.Explicit)
        result.append((cat, name))
    return result

class AsterixSamples:
    """Asterix sample generator."""
    def __init__(self, gen, sel, exp, populate_all_items):
        self.gen = gen
        self.expand = set(exp)
        self.populate_all_items = populate_all_items

        # for some specs it is not possible to generate valid record,
        # without knowing the profile, so skip those
        self.valid_specs = {}
        for (cat, spec) in sel['CATS'].items():
            if hasattr(spec, 'make_record') or hasattr(spec, 'is_valid'):
                self.valid_specs[cat] = spec
        assert self.valid_specs # non-empty list is required
        self.refs = sel['REFS']

    def __iter__(self):
        return self

    def random_record(self, cat, cls):
        gen = self.gen

        def random_var(var, name=None):

            if issubclass(var, ast.Element):
                return gen.bigint(var.bit_size)

            if issubclass(var, ast.Group):
                return gen.bigint(var.bit_size)

            if issubclass(var, ast.Extended):
                values = [gen.bigint(i) for i in var.groups_bit_sizes]
                values = values[0:1+(gen.next() % len(values))]
                return tuple(values)

            if issubclass(var, ast.Repetitive):
                n = 1 + (gen.next() % 10)
                return [gen.bigint(var.variation_bit_size) for i in range(n)]

            if issubclass(var, ast.Explicit):
                this_item = (cat, name)
                if not this_item in self.expand:
                    return None
                sub = self.refs[cat].variation
                val = random_var(sub)
                return sub(val).unparse_bits().to_bytes() or None # avoid empty

            if issubclass(var, ast.Compound):
                d = {}
                for (name, (sub, _fspec)) in var.subitems_dict.items():
                    populate_this_item = self.populate_all_items or gen.bool()
                    if populate_this_item:
                        x = random_var(sub, name)
                        if not x is None:
                            d[name] = x
                return d or None # turn {} into None, to skip this subitem
            raise Exception('internal error, unexpected variation', var)

        while True:

            if hasattr(cls, 'make_record'):
                var = cls.variation
                rec = cls.make_record(random_var(var))
            else:
                uap = gen.choose(list(cls.uaps.keys()))
                var = cls.uaps[uap]
                rec = cls.make_record_unsafe(uap, random_var(var))
                if not cls.is_valid(rec):
                    continue

            return rec

    def __next__(self):
        cat = self.gen.choose(list(self.valid_specs.keys()))
        cls = self.valid_specs[cat]
        rec = self.random_record(cat, cls)
        db = cls.make_datablock([rec])
        return db.unparse()

def gen_random(args):
    """Generate random samples."""
    sel = get_selection(args.empty_selection, args.cat or [], args.ref or [])
    exp = get_expansions(sel, args.expand or [])
    populate_all_items = args.populate_all_items
    seed = args.seed
    if seed is None:
        seed = random.randint(0,pow(2,64)-1)
    gen = PCG32(seed)

    tx = None
    for o in format_output:
        if o.__name__ == args.output:
            tx = o
            break
    assert tx

    for sample in AsterixSamples(gen, sel, exp, populate_all_items):
        tx.dump(sample)

def smax(n, s):
    if len(s) <= n:
        return s
    return s[0:n] + '|'

def asterix_decoder(args):
    sel = get_selection(args.empty_selection, args.cat or [], args.ref or [])
    exp = get_expansions(sel, args.expand or [])
    if args.truncate:
        truncate = lambda s: output(smax(args.truncate, s))
    else:
        truncate = lambda s: output(s)
    rx = None
    for i in format_input:
        if i.__name__ == args.input:
            rx = i
            break
    assert rx

    def too_deep(i):
        """Parsing level check."""
        max_level = args.parsing_level
        if max_level <= 0:
            return False
        return i > max_level

    def handle_variation(cat, i, var, path):
        if too_deep(i): return
        cls = var.__class__
        if isinstance(var, ast.Element):
            x = var.to_uinteger()
            if hasattr(var, 'table_value'):
                tv = var.table_value
                if tv is None:
                    tv = '(undefined value)'
                truncate('{}value: {} -> {}'.format('  '*i, x, tv))
            elif hasattr(var, 'to_string'):
                truncate('{}value: {} -> {}'.format('  '*i, x, repr(var.to_string())))
            elif hasattr(var, 'to_quantity'):
                truncate('{}value: {} -> {} {}'.format('  '*i, x, var.to_quantity(), var.__class__.quantity.unit))
            else:
                truncate('{}value: {} = {} = {}'.format('  '*i, x, hex(x), oct(x)))

        elif isinstance(var, ast.Group):
            for j in cls.subitems_list:
                if type(j) is tuple:
                    name = j[0]
                    sub = var.get_item(name)
                    bits = sub.unparse_bits()
                    truncate('{}{}: {}, len={} bits, bin={}'.format('  '*i, path+[name], sub.__class__.variation, len(bits), str(bits)))
                    handle_variation(cat, i+1, sub, path+[name])
                else:
                    truncate('{}Spare len={} bits'.format('  '*i, j.bit_size))

        elif isinstance(var, ast.Extended):
            for j in cls.subitems_list:
                for k in j:
                    if type(k) is tuple:
                        name = k[0]
                        sub = var.get_item(name)
                        if sub is None:
                            continue
                        bits = sub.unparse_bits()
                        truncate('{}{}: {}, len={} bits, bin={}'.format('  '*i, path+[name], sub.__class__.variation, len(bits), str(bits)))
                        handle_variation(cat, i+1, sub, path+[name])
                    else:
                        truncate('{}Spare len={} bits'.format('  '*i, k.bit_size))

        elif isinstance(var, ast.Repetitive):
            for cnt, sub in enumerate(var):
                truncate('{}subitem {}'.format('  '*i, cnt))
                handle_variation(cat, i+1, sub, path+[cnt])

        elif isinstance(var, ast.Explicit):
            this_item = (cat, path[0])
            if not this_item in exp:
                return
            sub = sel['REFS'][cat].variation
            bits = ast.Bits.from_bytes(var.raw)
            try:
                (val, b) = sub.parse_bits(bits)
                if len(b):
                    raise ast.AsterixError('Unexpected remaining bits in explicit item')
                handle_variation(cat, i, val, path)
            except ast.AsterixError as e:
                truncate('Error!', e)
                truncate('Unable to parse explicit subitem:', s.hex())
                if args.stop_on_error:
                    sys.exit(1)

        elif isinstance(var, ast.Compound):
            for j in cls.subitems_list:
                if j is None:
                    continue
                name = j[0]
                sub = var.get_item(name)
                if sub is None:
                    continue
                bits = sub.unparse_bits()
                truncate('{}{}: {}, len={} bits, bin={}'.format('  '*i, path+[name], sub.__class__.variation, len(bits), str(bits)))
                handle_variation(cat, i+1, sub, path+[name])
        else:
            raise Exception('internal error, unexpected variation', var)

    def handle_record(cat, i, rec):
        if too_deep(i): return
        raw = rec.unparse_bits().to_bytes()
        truncate('{}record: len={} bytes, hex={}'.format('  '*i, len(raw), raw.hex()))
        handle_variation(cat, i+1, rec, [])

    def handle_datablock(i, db):
        if too_deep(i): return
        cat = db.category
        truncate('{}datablock: cat={}, len={} bytes, records={}'.format('  '*i, cat, db.length, db.raw_records.hex()))
        spec = sel['CATS'].get(cat)
        if spec is None:
            return
        try:
            db = spec.parse(db)
            for rec in db.records:
                handle_record(cat, i+1, rec)
        except ast.AsterixError as e:
            truncate('Error! {}'.format(e))
            truncate('Unable to parse datablock: {}'.format(db.unparse().hex()))
            if args.stop_on_error:
                sys.exit(1)

    def handle_datagram(i, s):
        if too_deep(i): return
        truncate('{}datagram: len={} bytes, hex={}'.format('  '*i, len(s), s.hex()))
        try:
            dbs = ast.RawDatablock.parse(s)
        except ast.AsterixError as e:
            truncate('Error! {}'.format(e))
            truncate('Unable to parse datagram: {}'.format(s.hex()))
            if args.stop_on_error:
                sys.exit(1)
            return
        for db in dbs:
            handle_datablock(i+1, db)

    for line in fileinput.input('-'):
        (s, t) = rx.fetch(line)
        truncate('timestamp: {}'.format(t if t is not None else '<unknown>'))
        handle_datagram(1, s)

def main() -> None:

    parser = argparse.ArgumentParser(description='Asterix data processor.')

    parser.add_argument('--empty-selection', action='store_true',
        help='Use empty initial cat/ref selection instead of latest editions')

    parser.add_argument('--cat', nargs=2, metavar=('CAT', 'EDITION'),
        action='append',
        help='Explicit category selection')

    parser.add_argument('--ref', nargs=2, metavar=('CAT', 'EDITION'),
        action='append',
        help='Explicit expansion selection')

    parser.add_argument('--expand', nargs=2, metavar=('CAT', 'ITEM-NAME'),
        action='append',
        help='Expand CAT/ITEM-NAME with REF expansion')

    subparsers = parser.add_subparsers(required=True, help='sub-commands')

    # 'manifest' command
    parser_manifest = subparsers.add_parser('manifest',
        help='show available categories')
    parser_manifest.add_argument('--latest', action='store_true',
        help='show latest editions only')
    parser_manifest.set_defaults(func=show_manifest)

    # 'random' command
    parser_random = subparsers.add_parser('random', help='asterix sample generator')
    parser_random.add_argument('--seed', type=int,
        help='randomm generator seed value')
    parser_random.add_argument('--output',
        choices=[fmt.__name__ for fmt in format_output],
        default=format_output[0].__name__,
        help='output format, default: %(default)s')
    parser_random.add_argument('--populate-all-items',
        action='store_true',
        help='populate all defined items instead of random selection')
    parser_random.set_defaults(func=gen_random)

    # 'dump' command
    parser_dump = subparsers.add_parser('dump', help='asterix decoder')
    parser_dump.set_defaults(func=asterix_decoder)
    parser_dump.add_argument('--input',
        choices=[fmt.__name__ for fmt in format_input],
        default=format_input[0].__name__,
        help='input format, default: %(default)s')
    parser_dump.add_argument('--truncate', type=int,
        metavar='N', default=0,
        help='truncate long data lines to N characters or 0 for none, default: %(default)s')
    parser_dump.add_argument('--stop-on-error',
        action='store_true',
        help='exit on first parsing error')
    parser_dump.add_argument('--parsing-level', type=int,
        metavar='N', default=0,
        help='limit parsing depth, 0 for none, default: %(default)s')

    args = parser.parse_args()
    args.func(args)

if __name__ == '__main__':
    main()

